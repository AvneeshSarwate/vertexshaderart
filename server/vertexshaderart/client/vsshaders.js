window.vsartShaders = {"vs-header":"\nattribute float vertexId;\n\nuniform vec2 mouse;\nuniform vec2 resolution;\nuniform vec4 background;\nuniform float time;\nuniform float vertexCount;\nuniform sampler2D sound;\nuniform sampler2D floatSound;\nuniform sampler2D touch;\nuniform vec2 soundRes;\nuniform float _dontUseDirectly_pointSize;\n\nvarying vec4 v_color;\n  ","vs":"\n#define PI radians(180.)\n#define NUM_SEGMENTS 21.0\n#define NUM_POINTS (NUM_SEGMENTS * 2.0)\n#define STEP 5.0\n\nvec3 hsv2rgb(vec3 c) {\n  c = vec3(c.x, clamp(c.yz, 0.0, 1.0));\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  float point = mod(floor(vertexId / 2.0) + mod(vertexId, 2.0) * STEP, NUM_SEGMENTS);\n  float count = floor(vertexId / NUM_POINTS);\n  float offset = count * 0.02;\n  float angle = point * PI * 2.0 / NUM_SEGMENTS + offset;\n  float radius = 0.2;\n  float c = cos(angle + time) * radius;\n  float s = sin(angle + time) * radius;\n  float orbitAngle = count * 0.01;\n  float oC = cos(orbitAngle + time * count * 0.01) * sin(orbitAngle);\n  float oS = sin(orbitAngle + time * count * 0.01) * sin(orbitAngle);\n\n  vec2 aspect = vec2(1, resolution.x / resolution.y);\n  vec2 xy = vec2(\n      oC + c,\n      oS + s);\n  gl_Position = vec4(xy * aspect + mouse * 0.1, 0, 1);\n\n  float hue = (time * 0.01 + count * 1.001);\n  v_color = vec4(hsv2rgb(vec3(hue, 1, 1)), 1);\n}\n  ","vs2":"\n#define PI radians(180.)\n#define NUM_SEGMENTS 4.0\n#define NUM_POINTS (NUM_SEGMENTS * 2.0)\n#define STEP 5.0\n\nvec3 hsv2rgb(vec3 c) {\n  c = vec3(c.x, clamp(c.yz, 0.0, 1.0));\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  float point = mod(floor(vertexId / 2.0) + mod(vertexId, 2.0) * STEP, NUM_SEGMENTS);\n  float count = floor(vertexId / NUM_POINTS);\n  float snd = texture2D(sound, vec2(fract(count / 128.0), fract(count / 20000.0))).a;\n  float offset = count * 0.02;\n  float angle = point * PI * 2.0 / NUM_SEGMENTS + offset;\n  float radius = 0.2 * pow(snd, 5.0);\n  float c = cos(angle + time) * radius;\n  float s = sin(angle + time) * radius;\n  float orbitAngle =  count * 0.0;\n  float innerRadius = count * 0.001;\n  float oC = cos(orbitAngle + time * 0.4 + count * 0.1) * innerRadius;\n  float oS = sin(orbitAngle + time + count * 0.1) * innerRadius;\n\n  vec2 aspect = vec2(1, resolution.x / resolution.y);\n  vec2 xy = vec2(\n      oC + c,\n      oS + s);\n  gl_Position = vec4(xy * aspect + mouse * 0.1, 0, 1);\n\n  float hue = (time * 0.01 + count * 1.001);\n  v_color = vec4(hsv2rgb(vec3(hue, 1, 1)), 1);\n}\n  ","vs3":"\n#define NUM_SEGMENTS 128.0\n#define NUM_POINTS (NUM_SEGMENTS * 2.0)\n\nvec3 hsv2rgb(vec3 c) {\n  c = vec3(c.x, clamp(c.yz, 0.0, 1.0));\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main() {\n  float numLinesDown = floor(vertexCount / NUM_POINTS);\n  // produces 0,1, 1,2, 2,3, ...\n  float point = floor(mod(vertexId, NUM_POINTS) / 2.0) + mod(vertexId, 2.0);\n  // line count\n  float count = floor(vertexId / NUM_POINTS);\n\n  float u = point / NUM_SEGMENTS;  // 0 <-> 1 across line\n  float v = count / numLinesDown;  // 0 <-> 1 by line\n  float invV = 1.0 - v;\n\n  // Only use the left most 1/4th of the sound texture\n  // because there's no action on the right\n  float historyX = u * 0.25;\n  // Match each line to a specific row in the sound texture\n  float historyV = (v * numLinesDown + 0.5) / soundRes.y;\n  float snd = texture2D(sound, vec2(historyX, historyV)).a;\n\n  float x = u * 2.0 - 1.0;\n  float y = v * 2.0 - 1.0;\n  vec2 xy = vec2(\n      x * mix(0.5, 1.0, invV),\n      y + pow(snd, 5.0) * 1.0) / (v + 0.5);\n  gl_Position = vec4(xy * 0.5, 0, 1);\n\n  float hue = u;\n  float sat = invV;\n  float val = invV;\n  v_color = mix(vec4(hsv2rgb(vec3(hue, sat, val)), 1), background, v * v);\n}\n  ","vs4":"\n#define PI radians(180.)\n#define NUM_SEGMENTS 2.0\n#define NUM_POINTS (NUM_SEGMENTS * 2.0)\n#define STEP 1.0\n\nvoid main() {\n  float point = mod(floor(vertexId / 2.0) + mod(vertexId, 2.0) * STEP, NUM_SEGMENTS);\n  float count = floor(vertexId / NUM_POINTS);\n  float offset = count * sin(time * 0.01) + 5.0;\n  float angle = point * PI * 2.0 / NUM_SEGMENTS + offset;\n  float radius = pow(count * 0.00014, 1.0);\n  float c = cos(angle + time) * radius;\n  float s = sin(angle + time) * radius;\n  float orbitAngle =  pow(count * 0.025, 0.8);\n  float innerRadius = pow(count * 0.0005, 1.2);\n  float oC = cos(orbitAngle + count * 0.0001) * innerRadius;\n  float oS = sin(orbitAngle + count * 0.0001) * innerRadius;\n\n  vec2 aspect = vec2(1, resolution.x / resolution.y);\n  vec2 xy = vec2(\n      oC + c,\n      oS + s);\n  gl_Position = vec4(xy * aspect + mouse * 0.1, 0, 1);\n\n  float b = 1.0 - pow(sin(count * 0.4) * 0.5 + 0.5, 10.0);\n  b = 0.0;mix(0.0, 0.7, b);\n  v_color = vec4(b, b, b, 1);\n}\n  ","fs":"\nprecision mediump float;\n\nvarying vec4 v_color;\n\nvoid main() {\n  gl_FragColor = v_color;\n}\n  ","history-vs":"\nattribute vec4 position;\nattribute vec2 texcoord;\nuniform mat4 u_matrix;\nvarying vec2 v_texcoord;\n\nvoid main() {\n  gl_Position = u_matrix * position;\n  v_texcoord = texcoord;\n}\n  ","history-fs":"\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform float u_mix;\nuniform float u_mult;\nvarying vec2 v_texcoord;\n\nvoid main() {\n  vec4 color = texture2D(u_texture, v_texcoord);\n  gl_FragColor = mix(color.aaaa, color.rgba, u_mix) * u_mult;\n}\n  "}